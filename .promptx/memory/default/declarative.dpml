<?xml version="1.0" encoding="UTF-8"?>
<memory>
  <item id="mem_1751899234334_x09yn6kxw" time="2025/07/07 22:40">
    <content>
      依赖注入（Dependency Injection）是一种软件设计模式，用于实现控制反转（IoC），使代码更具可测试性和可维护性。在当前项目中，我们应采用依赖注入的最佳实践来解决跨项目调用的问题。关键要点包括：
    
      1. **依赖注入原则**：
      - 构造函数注入：适用于必需的依赖项
      - 属性注入：适用于可选的依赖项
      - 方法注入：适用于需要动态更改依赖项的情况
    
      2. **推荐做法**：
      - 使用接口或抽象类定义依赖项
      - 在服务容器中注册依赖关系
      - 避免过度使用依赖注入，保持简单清晰
    
      3. **问题排查建议**：
      - 检查依赖项是否正确注册
      - 确保生命周期管理合理（如单例、作用域等）
      - 查看是否有循环依赖的问题
    
      4. **与 Pocketbase 的集成建议**：
      - 将 Pocketbase 服务封装为接口
      - 在应用启动时注入具体实现
      - 提供 Mock 实现以便于单元测试
    
      通过这些措施，可以有效提升项目的模块化程度和可测试性。
    </content>
    <tags>#最佳实践</tags>
  </item>
  <item id="mem_1751899333673_tzixeixwd" time="2025/07/07 22:42">
    <content>
      针对Pocketbase集成的依赖注入实现指南
    
      1. **服务封装**
      - 创建IPocketbaseService接口，定义所有需要的Pocketbase操作
      - 实现PocketbaseService类，包含实际的Pocketbase集成逻辑
      - 提供MockPocketbaseService实现，用于单元测试
    
      2. **依赖注册**
      - 在应用启动时，根据环境配置注入正确的实现
      - 使用依赖注入容器管理服务生命周期
      - 支持开发、测试、生产环境的不同配置
    
      3. **服务使用**
      - 在控制器或业务逻辑类中通过构造函数注入IPocketbaseService
      - 统一通过接口调用服务方法，不直接依赖具体实现
      - 所有服务调用需包含异常处理和日志记录
    
      4. **通信渠道优化**
      - 定义统一的请求/响应模型
      - 实现请求验证和错误处理中间件
      - 添加性能监控和日志追踪
      - 支持同步和异步两种调用模式
    
      5. **跨项目调用建议**
      - 定义清晰的服务边界和API规范
      - 使用DTO（数据传输对象）进行跨项目数据交换
      - 实现版本控制以支持API演进
      - 添加安全认证和权限控制
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1751899507742_5w2bzy9gd" time="2025/07/07 22:45">
    <content>
      依赖注入实现指南 - Pocketbase集成要点
    
      1. **接口定义**
      ```typescript
      interface IPocketbaseService {
      getProduct(id: string): Promise&lt;Product&gt;
      listProducts(filter: ProductFilter): Promise&lt;Product[]&gt;
      createProduct(data: CreateProductData): Promise&lt;Product&gt;
      }
      ```
    
      2. **具体实现**
      ```typescript
      class PocketbaseService implements IPocketbaseService {
      private client: PocketbaseClient;
    
      constructor(config: ServiceConfig) {
      this.client = new PocketbaseClient(config);
      }
    
      async getProduct(id: string): Promise&lt;Product&gt; {
      // 实现具体的Pocketbase调用逻辑
      }
      }
      ```
    
      3. **Mock实现**
      ```typescript
      class MockPocketbaseService implements IPocketbaseService {
      private mockData: Product[];
    
      constructor(mockData: Product[]) {
      this.mockData = mockData;
      }
    
      getProduct(id: string): Promise&lt;Product&gt; {
      return Promise.resolve(this.mockData.find(p =&gt; p.id === id));
      }
      }
      ```
    
      4. **服务注册**
      ```typescript
      // 在应用启动时根据环境配置注入不同的实现
      const pocketbaseService = isProduction
      ? new PocketbaseService(prodConfig)
      : new MockPocketbaseService(mockProducts);
    
      // 注册到服务容器
      container.register(&#x27;IPocketbaseService&#x27;, { useValue: pocketbaseService });
      ```
    
      5. **服务使用**
      ```typescript
      // 在控制器中通过构造函数注入
      class ProductController {
      constructor(private pocketbaseService: IPocketbaseService) {}
    
      async getProductHandler(id: string) {
      try {
      const product = await this.pocketbaseService.getProduct(id);
      // 处理产品数据
      } catch (error) {
      // 统一错误处理
      }
      }
      }
      ```
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1751899650483_bh06u4nee" time="2025/07/07 22:47">
    <content>
      依赖注入实现指南 - Pocketbase集成优化建议
    
      1. **服务注册优化**
      ```typescript
      // 使用工厂模式创建服务实例
      const pocketbaseFactory = (config: ServiceConfig) =&gt; {
      return isProduction
      ? new PocketbaseService(config)
      : new MockPocketbaseService(mockProducts);
      };
    
      // 注册带生命周期管理的依赖
      container.register(&#x27;IPocketbaseService&#x27;, {
      useFactory: () =&gt; pocketbaseFactory(prodConfig),
      lifecycle: Lifecycle.singleton
      });
      ```
    
      2. **错误处理增强**
      ```typescript
      // 自定义Pocketbase错误类
      class PocketbaseError extends Error {
      constructor(public code: number, message: string, public details?: any) {
      super(message);
      this.name = &#x27;PocketbaseError&#x27;;
      }
      }
    
      // 在服务中使用自定义错误
      async getProduct(id: string): Promise&lt;Product&gt; {
      try {
      const record = await this.client.getProduct(id);
      if (!record) {
      throw new PocketbaseError(404, &#x27;Product not found&#x27;, { id });
      }
      return record;
      } catch (error) {
      // 转换Pocketbase错误为自定义错误
      throw new PocketbaseError(
      error.status || 500,
      `Failed to get product: ${error.message}`,
      error.body
      );
      }
      }
      ```
    
      3. **性能监控集成**
      ```typescript
      // 添加性能跟踪装饰器
      function trackPerformance(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const originalMethod = descriptor.value;
    
      descriptor.value = async function (...args: any[]) {
      const start = Date.now();
      try {
      return await originalMethod.apply(this, args);
      } finally {
      const duration = Date.now() - start;
      console.log(`[Performance] ${propertyKey} took ${duration}ms`);
      // 这里可以集成到实际的监控系统
      }
      };
    
      return descriptor;
      }
    
      // 在服务方法上使用装饰器
      class PocketbaseService implements IPocketbaseService {
      @trackPerformance
      async getProduct(id: string): Promise&lt;Product&gt; {
      // 方法实现
      }
      }
      ```
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1751899681011_xu1p5su7x" time="2025/07/07 22:48">
    <content>
      跨项目通信优化指南
    
      1. **统一通信接口**
      ```typescript
      // 定义标准请求/响应模型
      interface Request {
      id: string;
      timestamp: number;
      correlationId?: string;
      }
    
      interface Response&lt;T&gt; {
      data?: T;
      error?: {
      code: number;
      message: string;
      details?: any;
      };
      metadata?: {
      timestamp: number;
      duration: number;
      correlationId: string;
      };
      }
      ```
    
      2. **请求验证中间件**
      ```typescript
      function validateRequest(request: Request) {
      if (!request.id) {
      throw new Error(&#x27;Missing required id&#x27;);
      }
    
      // 添加关联ID用于跟踪
      request.correlationId = request.correlationId || generateCorrelationId();
      return request;
      }
    
      // 使用示例
      async getProductHandler(id: string) {
      const request = validateRequest({ id });
      try {
      const product = await this.pocketbaseService.getProduct(id);
      // 日志记录带关联ID
      logger.info(`Product retrieved [${request.correlationId}]`, { id });
      return { data: product, metadata: { correlationId: request.correlationId }};
      } catch (error) {
      // 错误处理带详细元数据
      logger.error(`Error retrieving product [${request.correlationId}]`, {
      error: error.message,
      stack: error.stack,
      request
      });
      return {
      error: {
      code: error.code || 500,
      message: `Failed to get product: ${error.message}`,
      details: error.details
      },
      metadata: {
      correlationId: request.correlationId
      }
      };
      }
      }
      ```
    
      3. **分布式追踪集成**
      ```typescript
      // 创建带追踪上下文的装饰器
      function withTracing(name: string) {
      return (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
      const originalMethod = descriptor.value;
    
      descriptor.value = async function (...args: any[]) {
      const span = tracer.startSpan(`${name}.${propertyKey}`);
      try {
      // 将追踪上下文传递给依赖服务
      args[0].context = { ...args[0].context, span };
      return await originalMethod.apply(this, args);
      } finally {
      span.end();
      }
      };
    
      return descriptor;
      };
      }
    
      // 在服务中使用分布式追踪
      class PocketbaseService implements IPocketbaseService {
      @withTracing(&#x27;pocketbase&#x27;)
      async getProduct(context: RequestContext): Promise&lt;Product&gt; {
      // 使用context.span进行分布式追踪
      return this.client.getProduct(context.id);
      }
      }
      ```
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1751899860615_5ea6hsuat" time="2025/07/07 22:51">
    <content>
      Pocketbase集成最佳实践总结
    
      1. **接口设计原则**
      - 使用清晰的接口命名规范
      - 接口方法应遵循单一职责原则
      - 定义明确的输入输出模型
      - 包含必要的文档注释
    
      2. **实现优化建议**
      - 使用工厂模式创建服务实例
      - 实现生命周期管理（单例/作用域）
      - 添加性能监控和日志追踪
      - 统一错误处理机制
    
      3. **跨项目通信规范**
      - 使用标准请求/响应模型
      - 实现请求验证和关联ID跟踪
      - 添加分布式追踪支持
      - 定义清晰的服务边界和API规范
    
      4. **测试策略**
      - 提供Mock实现用于单元测试
      - 创建集成测试覆盖核心功能
      - 实现端到端测试验证流程
      - 编写性能测试确保系统稳定性
    </content>
    <tags>#最佳实践 #流程管理</tags>
  </item>
  <item id="mem_1751900219597_ctxcx6yn0" time="2025/07/07 22:56">
    <content>
      XiaoAn角色专业知识体系
    
      1. **Pocketbase集成最佳实践**
      - 使用工厂模式创建服务实例
      - 实现生命周期管理（单例/作用域）
      - 添加性能监控和日志追踪
      - 统一错误处理机制
    
      2. **跨项目通信规范**
      - 使用标准请求/响应模型
      - 实现请求验证和关联ID跟踪
      - 添加分布式追踪支持
      - 定义清晰的服务边界和API规范
    
      3. **代码质量标准**
      - 可读性：代码结构清晰，命名规范
      - 可维护性：模块划分合理，低耦合高内聚
      - 健壮性：能正确处理各种输入和边界条件
      - 性能性：满足预期的性能要求
    
      4. **开发流程规范**
      - 需求分析 → 技术设计 → 编码实现 → 质量验证 → 交付部署
      - 每个环节都要考虑：效率、质量、风险、可维护性
      - 始终以高质量完成开发任务为最终目标
    </content>
    <tags>#最佳实践 #流程管理</tags>
  </item>
  <item id="mem_1751900291490_vk3oe8p3f" time="2025/07/07 22:58">
    <content>
      XiaoAn角色专业知识体系
    
      1. **Pocketbase集成最佳实践**
      - 使用工厂模式创建服务实例
      - 实现生命周期管理（单例/作用域）
      - 添加性能监控和日志追踪
      - 统一错误处理机制
    
      2. **跨项目通信规范**
      - 使用标准请求/响应模型
      - 实现请求验证和关联ID跟踪
      - 添加分布式追踪支持
      - 定义清晰的服务边界和API规范
    
      3. **代码质量标准**
      - 可读性：代码结构清晰，命名规范
      - 可维护性：模块划分合理，低耦合高内聚
      - 健壮性：能正确处理各种输入和边界条件
      - 性能性：满足预期的性能要求
    
      4. **开发流程规范**
      - 需求分析 → 技术设计 → 编码实现 → 质量验证 → 交付部署
      - 每个环节都要考虑：效率、质量、风险、可维护性
      - 始终以高质量完成开发任务为最终目标
    </content>
    <tags>#最佳实践 #流程管理</tags>
  </item>
  <item id="mem_1751900553947_7olrtyaj4" time="2025/07/07 23:02">
    <content>
      XiaoAn角色专业知识体系
    
      1. **Pocketbase集成最佳实践**
      - 使用工厂模式创建服务实例
      - 实现生命周期管理（单例/作用域）
      - 添加性能监控和日志追踪
      - 统一错误处理机制
    
      2. **跨项目通信规范**
      - 使用标准请求/响应模型
      - 实现请求验证和关联ID跟踪
      - 添加分布式追踪支持
      - 定义清晰的服务边界和API规范
    
      3. **代码质量标准**
      - 可读性：代码结构清晰，命名规范
      - 可维护性：模块划分合理，低耦合高内聚
      - 健壮性：能正确处理各种输入和边界条件
      - 性能性：满足预期的性能要求
    
      4. **开发流程规范**
      - 需求分析 → 技术设计 → 编码实现 → 质量验证 → 交付部署
      - 每个环节都要考虑：效率、质量、风险、可维护性
      - 始终以高质量完成开发任务为最终目标
    </content>
    <tags>#最佳实践 #流程管理</tags>
  </item>
</memory>